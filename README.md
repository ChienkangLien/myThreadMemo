# myThreadMemo
並發：在同一時刻，有多個指令在單個CPU上交替執行。
並行：在同一時刻，有多個指令在多個CPU上同時執行。

實現方式
繼承 Thread 類並重寫 run 的方法：
* 優勢：在 run() 方法內獲取當前線程直接使用 this 就可以了，無須使用Thread.currentThread() 方法。
* 缺點：不能繼承其它類。任務和代碼不分離，多個線程執行一樣的任務時需要多份任務代碼（需要在run方法中寫同樣的代碼）。

實現 Runnable 接口的 run 方法，傳給 Thread ：
* 優勢：任務和代碼分離。可以繼承其他類。

實現Callable 接口的 call() 方法，傳給 FutureTask ：
* 優勢：擁有返回值。

---
* 分時調度模型：所有線程輪流使用 CPU 的使用權，平均分配每個線程占用 CPU 的時間片
* 搶占式調度模型：優先讓優先級高的線程使用CPU，如果線程的優先級相同，那麽會隨機選擇一個，優先級高的線程獲取的 CPU 時間片相對多一些

Java使用的是搶占式調度模型

---
守護線程：當其他非守護線程執行完畢後，守護線程會陸續結束、不會從頭到尾執行；應用場景可能是聊天室，聊天如果結束、傳輸到一半的文件也跟著結束

---
sleep()：由當前線程來休眠
yield()：出讓當前CPU的執行權
join()：插入到當前線程(main)之前

![image](../images/lifecycle.png)

---
安全性
1. 同步代碼塊：鎖默認打開，有一個線程進去了即會關閉、塊中代碼執行完畢解鎖
```java=
synchronized(鎖(任意物件)) { 
	操作共享數據的代碼 
}
```
2. 同步方法：鎖住方法中的代碼，鎖對象不能自己指定；非靜態是this、靜態是當前類的字節碼物件(.class)
```java=
修飾符 static synchronized 返回值類型 方法名(方法參數) { 
	方法體；
}
```
3. Lock鎖：為了更清晰的表達如何加鎖和釋放鎖，JDK5以後提供了一個新的鎖對象Lock；Lock是接口不能直接實例化，使用實現類ReentrantLock來實例化

死鎖：由於兩個或者多個線程互相持有對方所需要的資源，導致這些線程處於等待狀態，無法前往執行；什麽情況下會產生死鎖，資源有限、同步嵌套